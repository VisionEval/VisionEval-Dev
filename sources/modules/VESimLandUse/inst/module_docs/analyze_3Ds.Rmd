---
title: "VE-State Bzone Synthesis: Synthesizing Zones with Activity Density, Diversity, and Destination Accessibility Characteristics"
author: "Brian Gregor"
output: html_document
---

# Introduction
This paper documents the process and results for creating a methodology for synthesizing Bzones in urbanized areas. To date, a method has been developed that synthesizes Bzones which reflect the activity density, diversity, and destination accessibility characteristics of urbanized area block groups. Activity density is a measure of the amount activity present in each block group. This is the *D1d* measure in the Smart Location Database (SLD), the primary data source used for developing the zone synthesis methods. The synthesized measure is the number of households and jobs per acre of land area in the block group. Diversity is a measure of the mixing of different types of land uses in each block group. The synthesized measure is the ratio of jobs to housing in the block group. This is the *D2a_JpHH* measure in the SLD. Destination accessibility is a measure of the amount of activity present in the vicinity of each block group. The measure used is the harmonic mean of the population of block groups within 5 miles and employment within 2 miles of the block group.  (Distance measurements are from block group centroid to block group centroid.) This measure is used instead of destination accessibility measures in the SLD are auto oriented (for example, jobs within 45 minute travel time) and not very useful for smaller urbanized areas. The harmonic mean of population and employment was found to be useful for distinguishing *area types*, one of the dimensions in the *place type* system that will be implemented in the Bzone synthesis process. A national mapping of place types can be seen at this [link](https://github.com/gregorbj/Placetypes_USA). 

Creating SimBzones and attributing them with activity density, diversity, and destination accessibility characteristics is the first step in the VE-State Bzone synthesis process. In addition, as part of this process, numbers of households and jobs are assigned to each SimBzone. Later steps will splits jobs by employment type (retail, service, other), determine numbers of single family and multi-family housing units, identify place types, and model design and distance to transit attributes.  

## Data  
EPA's [Smart Location Database](https://www.epa.gov/smartgrowth/smart-location-mapping) is the principal source of data used for developing the method for the synthesizing Bzones. The SLD includes a large number of land use and transportation measures at the Census block group level for the year 2010. The destination accessibility measure described above was added to the SLD dataset using the locations of the block group centroids. 

The SLD includes data on urbanized and non-urbanized areas. Only the data for urbanized areas having populations of 50,000 or more were used to develop the zone synthesis methodology. A separate method will be developed to synthesize Bzones representing smaller urban areas (i.e. towns) and rural areas. In addition, some data cleaning was done by removing block group records that had no activity or land area. This dataset includes data on 139,564 block groups in 431 urbanized areas. The separate state components of urbanized areas that cross state boundaries were identified because the characteristics of block groups in each state may differ substantially and it is common practice for state models to only include the portion of the urbanized area located in the state.

## Summary of Methodology
The following list summarizes the Bzone synthesis methods developed to date:

1) The main inputs that drive the process are numbers of households by Azone, employment by Azone, the geographic extent of the urbanized area, and the proportional distribution of Azone households and employment by location type (rural, town, metropolitan). (Note that metropolitan in this context refers to the urbanized portion of the metropolitan area.) From these data, the amounts of jobs and households to be allocated to urbanized area SimBzones and the average activity density of the urbanized area can be computed.

2) SimBzones are created to have approximately equal amounts of activity: approximately the median value for urbanized area block groups in the SLD (750/ac).

3) The distributions of activity density, diversity, and destination accessibility are simplified by splitting them into levels: 20 levels for density, 5 levels for diversity, and 20 levels for destination accessibility.

4) A profile is developed for each urbanized area in the SLD dataset. In addition, profiles are developed for 6 urbanized area size categories to use when data for a specific metropolitan area is not available. The profiles include:
  - The proportion of total urbanized area activity at each density level;
  - The average block group activity density at each density level;
  - The proportion of activity by diversity level for each density level;
  - Distributions of the employment proportions of activity at each diversity level;
  - The proportion of activity by destination accessibility level for each density level;
  - The average block group destination accessibility at each destination accessibility level.

5) A profile for the entire set of urbanized areas is also developed to fill to fill missing values in individual urbanized area profiles when necessary to project future (or past) conditions.

6) The first step after the total amount of activity and land area has been assigned to an urbanized area is to create SimBzones to contain the projected urbanized area activity. The number of SimBzones for an urbanized area is the whole number result (by rounding) of dividing the total activity by 750. The remainder (positive or negative) is randomly allocated to the SimBzones. This allocation is done for each Azone portion of the urbanized area to assure that the values for SimBzones in each Azone are consistent with Azone household and jobs inputs.

7) Next, each SimBzone is assigned an activity density level. First a proportional allocation of activity to activity density levels is calculated such that the distribution averages to the average density for the urbanized area. This is accomplished by starting with the urbanized area profile of the proportional distribution by activity density level and then adjusting those proportions in small increments until the average density for the urbanized area is achieved. The mean density profile for the urbanized area is used in this calculation. Missing values in the mean density profile are filled in with values from the profile for urbanized areas as a whole. The proportional allocation of activity by density level is used as a sampling distribution to assign each SimBzone a density level. This process is carried out separately for each Azone portion of the urbanized area. A final density adjustment is made so that the average activity density in each Azone urbanized area matches input assumptions. 

8) After each SimBzone has an assigned activity level, it is assigned a diversity level. This is accomplished by using the urbanized area profile of proportional allocations of activity by diversity level for each activity density level for sampling distributions. Missing values are filled in from the overall urbanized area profile. Once the diversity level has been chosen a value for the employment proportion of activity is picked for each SimBzone from the employment proportions distributions. The employment proportions are used to make an initial calculation of employment in each SimBzone. That employment is adjusted as necessary to match the urbanized area employment total in each Azone. The number of SimBzone households is then calculated.

9) Bzones are assigned destination accessibility levels in a similar manner. The urbanized area profile of proportional allocations of activity by destination accessibility level are used as sampling distributions to determine destination accessibility levels. Missing values are filled in from the overall urbanized area profile. The specific destination accessibility values are the mean values computed for the levels for the urbanized area. If destination accessibility proportions are missing for one or more density levels, they are filled in from the profile for urbanized areas as a whole.

## Issues
The current GreenSTEP model allows users to specify a proportion of households located in urban mixed-use neighborhoods. Should users of VE-State be able to similarly specify the proportion of activity to be allocated to SimBzones that are in the mixed-use category? If so, the way that users would specify this and the method for adjusting SimBzone densities to match user inputs need to be developed. In addition, some guards should be established to prevent users from specifying unreasonable mix proportions.

The current GreenSTEP model does not allow users to adjust the density distribution. I don't think VE-State should allow this either. Nor should it allow users to adjust the destination accessibility distribution.

## Next Steps
A number of things need to be done to complete the synthetic zone generation process:
1) Develop method for splitting employment into categories used by multi-modal model: retail, service, other.
2) Develop method for determining place types.
3) Tabulate design and distance to transit attributes used by the multi-modal model by place type for each urbanized area. Develop a method for users to input targets for these attributes by place type.
4) Create the method for determining SimBzone housing type (single-family, multifamily) proportions.
5) Modify the method in the VEPredictHousing module to work with SimBzones. The VEPredictHousing method requires inputs on the mix of households by income quartile for each Bzone. This enables the distributions of households by income to reflect observed distributions and enables users to model the effects of gentrification. Should something similar be incorporated in VE-State?
6) Develop approaches for user inputs for parking policies, travel demand management policies, and car service availability.




```{r echo=FALSE}
#======
#SET UP
#======
#Load libraries
library(visioneval)
library(plot3D)

#Load 5Ds data frame
D_df <- readRDS("5Ds_df.rds")


#==================================================
#DEFINE FUNCTIONS USED IN MULTIPLE PLACES IN SCRIPT
#==================================================

#Define function to add a smoothed line to binned values
#-------------------------------------------------------
addSmoothLine <- function(X_, Y_, ...) {
  X_ <- X_[!is.na(Y_)]
  Y_ <- Y_[!is.na(Y_)]
  XY_SS <-smooth.spline(Y_ ~ X_)
  XPred_ <- seq(X_[1], X_[length(X_)], length = length(X_) * 10)
  lines(XPred_, predict(XY_SS, XPred_)$y, ...)
}

#Define a function to plot distributions for an urbanized area and compare with
#the distribution for all urbanized areas
#------------------------------------------------------------------------------
plotDist <- function(UZA_NAME, VarName, LogTransform = TRUE, ...) {
  UzaDen <- round(ActDen_Ua[UZA_NAME], 1)
  Title <- paste0(UZA_NAME, "\n", "(Ave ", UzaDen, " HH & Jobs per acre)")
  if (LogTransform) {
    Dat_ <- log(D_df[,VarName])
    Xlim_ <- range(Dat_[!is.infinite(Dat_)])
    Var_ <- Dat_[D_df$UZA_NAME == UZA_NAME]
    Var_ <- Var_[!is.infinite(Var_)]
  } else {
    Dat_ <- D_df[,VarName]
    Xlim_ <- range(Dat_)
    Var_ <- Dat_[D_df$UZA_NAME == UZA_NAME]
  }
  plot(density(Var_), xlim = Xlim_, main = Title, ...)
  lines(density(Dat_), lty = 2)
}

#Function to calculate average density using group data
#------------------------------------------------------
calcAveDensity <- function(AveDensity_, PropActivity_) {
  sum(1 / sum(PropActivity_ / AveDensity_, na.rm = TRUE), na.rm = TRUE)
}


#===============================
#CALCULATE URBANIZED AREA VALUES
#===============================

#Limit dataset to areas with populations >= 50,000
#-------------------------------------------------
#Calculate area population and activity
TotPop_Ua <- tapply(D_df$TOTPOP10, D_df$UA_NAME, sum)
#Limit dataset to urbanized areas having populations >= 50,000
AllD_df <- D_df
D_df <- D_df[D_df$UA_NAME %in% names(TotPop_Ua)[TotPop_Ua >= 50000],]

#Calculate activity size category
#--------------------------------
TotAct_Ua <- tapply(D_df$TOTACT, D_df$UA_NAME, sum)
SzBrk_ <- c(0, 5e4, 1e5, 5e5, 1e6, 5e6, max(TotAct_Ua))
Sz <- c("small", "medium-small", "medium", "medium-large", "large", "very-large")
SzGrp_Ua <- cut(TotAct_Ua, SzBrk_, labels = Sz, include.lowest = TRUE)
names(SzGrp_Ua) <- names(TotAct_Ua)
D_df$UZA_SIZE <- SzGrp_Ua[match(D_df$UA_NAME, names(SzGrp_Ua))]
rm(TotAct_Ua, SzBrk_, SzGrp_Ua)

#Calculate overall urbanized area activity density
#-------------------------------------------------
Tmp_ls <- split(D_df[,c("TOTACT", "AC_LAND", "TOTPOP10")], D_df$UZA_NAME)
ActDen_Ua <- unlist(lapply(Tmp_ls, function(x){
  sum(x$TOTACT) / sum(x$AC_LAND)
}))
D_df$UZA_ACTDEN <- ActDen_Ua[D_df$UZA_NAME]
rm(Tmp_ls)

#Identify selected urbanized areas to use in comparison plots
#------------------------------------------------------------
UzaToPlot_ <- c(
  "Atlanta, GA",
  "Jacksonville, FL",
  "Cincinnati, OH",
  "Dallas--Fort Worth--Arlington, TX",
  "Baltimore, MD",
  "Denver--Aurora, CO",
  "Portland, OR",
  "San Francisco--Oakland, CA",
  "New York--Newark, NY"
)
```

# Evaluate the Distributions of 3D Variables for Urbanized Areas
The block group values for activity density, diversity, and destination accessibility are approximately log normally distributed as shown in the following graphs.

```{r echo=FALSE}
#==============================================================
#EVALUATE THE DISTRIBUTIONS OF 3D VARIABLES FOR URBANIZED AREAS
#==============================================================

#Plot overall urbanized area log-transformed distributions
#---------------------------------------------------------
#Plot log distributions - these look fairly normal
#D2A_JPHH has some 0 and infinite values so just plot non-zero values for that
InitPar_ls <- par(mfrow = c(2,2), oma = c(0,0,3,0))
with(D_df, {
  plot(density(log(D1D)),
       xlab = "Log of Jobs & HHs Per Acre",
       main = "Density of Jobs & HHs\n(D1D)")
  plot(density(log(D2A_JPHH[D2A_JPHH != 0 & !is.infinite(D2A_JPHH)])), 
       xlab = "Log of Jobs / HHs",
       main = "Diversity: Jobs-Housing Ratio\n(D2A_JPHH)")
  plot(density(log(D5)), 
       xlab = "Log of Accessibility\n(see text)",
       main = "Destination Accessibility\n(D5)")
  mtext("Distributions of Census Block Group 3D Measures for All Urbanized Areas",
        side = 3, outer = TRUE)
})
par(InitPar_ls)
rm(InitPar_ls)
```

The following figure shows the density distributions for 9 example urbanized areas arranged from least to most densely developed. The solid lines show the density distributions for the urbanized areas. The dashed lines show the average density distribution for all urbanized areas. Note that as urbanized area density increases the density distribution shifts to the right.

```{r echo=FALSE}
#Plot activity density (D1D) distribution for selected urbanized areas
#---------------------------------------------------------------------
InitPar_ls <- par(mfrow = c(3,3), oma = c(0, 0, 2.2, 0))
for (Ua in UzaToPlot_) {
  plotDist(Ua, "D1D", ylim = c(0, 0.8), xlab = "Natural log of D1D")
}
mtext("Block Group Activity Density Distribution (D1D) for Selected Urbanized Areas\nCompared to Distribution for All Urbanized Areas (dashed line)", outer = TRUE, line = -0.5)
par(InitPar_ls)
```

The following figure shows the diversity distributions for the example urbanized areas. Notice that there is little variation in the distributions among the urbanized areas. All are very similar to the overall urbanized area distribution.

```{r echo=FALSE}
#Plot diversity (D2A_JPHH) distribution for selected urbanized areas
#-------------------------------------------------------------------
InitPar_ls <- par(mfrow = c(3,3), oma = c(0, 0, 2.2, 0))
for (Ua in UzaToPlot_[order(ActDen_Ua[UzaToPlot_])]) {
  plotDist(Ua, "D2A_JPHH", ylim = c(0, 0.35), xlab = "Natural log of D2A_JPHH")
}
mtext("Block Group Activity Diversity Distribution (D2A_JPHH) for Selected Urbanized Areas\nCompared to Distribution for All Urbanized Areas (dashed line)", outer = TRUE, line = -0.5)
par(InitPar_ls)
```

The following figure shows the destination accessibility distributions for the example urbanized areas. As with the density distributions, these shift to the right as the urbanized area density increases.

```{r echo=FALSE}
#Plot destination accessibility (D5) distribution for selected urbanized areas
#-----------------------------------------------------------------------------
InitPar_ls <- par(mfrow = c(3,3), oma = c(0, 0, 2.2, 0))
for (Ua in UzaToPlot_[order(ActDen_Ua[UzaToPlot_])]) {
  plotDist(Ua, "D5", ylim = c(0, 0.5), xlab = "Natural log of D5")
}
mtext("Block Group Destination Accessibility Distribution (D5) for Selected Urbanized Areas\nCompared to Distribution for All Urbanized Areas (dashed line)", outer = TRUE, line = -0.5)
par(InitPar_ls)
#Clean up
rm(Ua, InitPar_ls)
```

The following 3 figures present relationships between these 3Ds measures. Diversity is weakly correlated with density and destination accessibility. Density and destination accessibility are more strongly correlated.

```{r echo=FALSE}
#Prepare data to compare correlations between 3Ds
#------------------------------------------------
T_df <- D_df[,c("D1D", "D2A_JPHH", "D5")]
T_df$LogD1D <- log(T_df$D1D)
T_df$LogD2A_JPHH <- log(T_df$D2A_JPHH)
T_df$LogD5 <- log(T_df$D5)
T_df <- T_df[!is.infinite(T_df$LogD2A_JPHH),]
D1D_ <- T_df$LogD1D
D2A_JPHH_ <- T_df$LogD2A_JPHH
D5_ <- T_df$LogD5

#Present the relationship of diversity with density
#--------------------------------------------------
plot(D1D_, D2A_JPHH_, pch = ".", xlab = "Log D1D (density)", 
     ylab = "Log D2A_JPHH (diversity)",
     main = "Relationship of Diversity with Density")
Cor <- round(cor(D2A_JPHH_, D1D_), 2)
Text <- paste("Correlation Coefficient =", Cor)
text(-6, 9, labels = Text, pos = 4)
rm(Cor, Text)

#Present the relationship of destination accessibility with density
#------------------------------------------------------------------
plot(D1D_, D5_, pch = ".", xlab = "Log D1D (density)", 
     ylab = "Log D5 (destination accessibility)",
     main = "Relationship of Destination Accessibility with Density")
Cor <- round(cor(D5_, D1D_), 2)
Text <- paste("Correlation Coefficient =", Cor)
text(-6, 13, labels = Text, pos = 4)
rm(Cor, Text)

#Present the relationship of diversity with destination accessibility
#--------------------------------------------------------------------
plot(D5_, D2A_JPHH_, pch = ".", xlab = "Log D5 (destination accessibility)", 
     ylab = "Log D2A_JPHH (diversity)",
     main = "Relationship of Diversity with Destination Accessibility")
Cor <- round(cor(D2A_JPHH_, D5_), 2)
Text <- paste("Correlation Coefficient =", Cor)
text(1, 9, labels = Text, pos = 4)
rm(Cor, Text)
#Clean up
rm(T_df, D1D_, D2A_JPHH_, D5_)
```

# Define Density Levels
Activity density levels are defined by dividing the log transformation of the distribution into 20 equal intervals and then untransforming the result. The proportion of the urbanized area activity in each bin is tabulated for all urbanized areas and for each individual urbanized area. It is also tabulated by urbanized area size group where size groups are defined by the total of households and jobs in the urbanized area as follows: 

| Category     | Value Range |
|:-------------|:------------|
|small         |0 - 5e4      |
|medium-small  |5e4 - 1e5    |
|medium        |1e5 - 5e5    | 
|medium-large  |5e5 - 1e6    |
|large         |1e6 - 5e6    |
|very-large    |5e6+         |

```{r echo=FALSE}
#================================================
#DEFINE AND ANALYZE ACTIVITY DENSITY (D1D) LEVELS
#================================================
#
#Define activity density levels
#------------------------------
#Determine breaks by dividing log of D1D into 20 equal intervals
D1DGrpBrk_ <- local({
  LogD1D_ <- log(D_df$D1D)
  Interval <- diff(range(LogD1D_)) / 20
  LogBreaks_ <- min(LogD1D_) + 0:20 * Interval
  exp(LogBreaks_)
})
#Make sure the minimum and maximum values bound the breaks
D1DGrpBrk_[1] <- min(D_df$D1D)
D1DGrpBrk_[length(D1DGrpBrk_)] <- max(D_df$D1D)
#Identify the density group for each block group
D1DGrp_ <- cut(D_df$D1D, breaks = D1DGrpBrk_, include.lowest = TRUE)
#Calculate the average density for each quantile
D1DGrpAve_ <- unlist(lapply(split(D_df, D1DGrp_), function(x) {
  sum(x$TOTACT) / sum(x$AC_LAND)
}))
#Calculate total activity in each quantile
D1DGrpTotAct_ <- tapply(D_df$TOTACT, D1DGrp_, sum)
#Check average urbanized area density calculated from groups
AveD1DCompare_ <- c(
  Ave = with(D_df, sum(TOTACT) / sum(AC_LAND)),
  BinAve = sum(D1DGrpTotAct_) / sum(D1DGrpTotAct_ / D1DGrpAve_)
)
#Add D1DGrp to D_df
D_df$D1DGrp <- D1DGrp_
#Calculate the proportion of total activity by group
D1DGrpPropAct_ <- D1DGrpTotAct_ / sum(D1DGrpTotAct_)
#Create a list to save the urbanized area D1D group data
D1DGrp_ls <- list(
  AveDensity = D1DGrpAve_,
  PropActivity = D1DGrpPropAct_
)
```

The following figure shows the overall proportional distribution of urbanized area activity by density group.

```{r echo=FALSE}
#Plot activity proportions and average density by density group
#--------------------------------------------------------------
#Plot the proportion of total activity by group
plot(1:20, D1DGrpPropAct_,
     xlab = "Activity Density (D1D) Group",
     ylab = "Proportion of Activity (HHs & Jobs)",
     main = "Proportions of Activity by Activity Density Group\nBlock Groups in All Urbanized Areas")
addSmoothLine(1:20, D1DGrpPropAct_, lty = 2)
```

In addition, for each of these groupings the average density by activity level is computed. This information is used to calculate overall density and to make density adjustments so that the density of urbanized area SimBzones 'sums up' to the overall density of the urbanized area. The following figure shows the average density by density level for all urbanized areas. Average density by density level is also computed for each urbanized area identified in the SLD and for each of the urbanized area size categories.

```{r echo=FALSE}
#Plot the group D1D averages
plot(1:20, D1DGrpAve_,
     xlab = "Activity Density (D1D) Group",
     ylab = "Average Density (HHs + Jobs per Acre)",
     main = "Average Activity Density by Activity Density Group\nBlocks Groups in All Urbanized Areas")
addSmoothLine(1:20, D1DGrpAve_, lty = 2)
#Clean up
rm(D1DGrpBrk_, D1DGrp_, D1DGrpTotAct_, D1DGrpAve_, D1DGrpPropAct_)

#Calculate activity density bin information for urbanized areas
#--------------------------------------------------------------
#Split data by urbanized area
D_Ua_df <- split(D_df, D_df$UZA_NAME)
#Calculate average density and proportion of activity by density group
D1DGrp_Ua_ls <- lapply(D_Ua_df, function(x) {
  GrpSplit_ls <- split(x, x$D1DGrp)
  list(
    AveDensity =
      unlist(lapply(GrpSplit_ls, function(x) sum(x$TOTACT) / sum(x$AC_LAND))),
    PropActivity =
      tapply(x$TOTACT, x$D1DGrp, sum) / sum(x$TOTACT)
  )
})
rm(D_Ua_df)
#Split data by urbanized area size category
D_Sz_df <- split(D_df, D_df$UZA_SIZE)
#Calculate average density and proportion of activity by density group
D1DGrp_Sz_ls <- lapply(D_Sz_df, function(x) {
  GrpSplit_ls <- split(x, x$D1DGrp)
  list(
    AveDensity =
      unlist(lapply(GrpSplit_ls, function(x) sum(x$TOTACT) / sum(x$AC_LAND))),
    PropActivity =
      tapply(x$TOTACT, x$D1DGrp, sum) / sum(x$TOTACT)
  )
})
#Add generic urbanized areas by size to urbanized area list
for (sz in Sz) {
  D1DGrp_Ua_ls[[sz]] <- D1DGrp_Sz_ls[[sz]]
}
rm(D_Sz_df, D1DGrp_Sz_ls)


#Check that density average calculated from bins are same as overall average
#for every urbanized area
#---------------------------------------------------------------------------
#Calculate average density for all urbanized areas
AveDen_Ua <- unlist(lapply(D1DGrp_Ua_ls, function(x) {
  calcAveDensity(x$AveDensity, x$PropActivity)
}))
#Values are the same
#summary(AveDen_Ua[!(names(AveDen_Ua) %in% Sz)] / ActDen_Ua)
rm(AveDen_Ua)
```

# Predicting Changes in Zone Density
While the synthetic zone generation process uses observed urban area distributions, it is necessary to incorporate a process for adjusting the distributions so that they are consistent with model input assumptions for overall urbanized area activity density. If urbanized area density decreases, the distribution needs to shift to the left, and if overall density increases, the distribution needs to shift to the right. The method shifts the distribution to the left or right in small increments by weighted averaging of the activity proportions value at each level with the value of the bin to the right (if the distribution shifts to the left) and vise verse if the distribution shifts to the right. With each increment, the average urbanized area density is calculated using the revised activity proportions and the average density per bin. The iteration stops when the average density is within 1% of the target. At that point, final adjustments are made to the bin average densities so that the target density is matched exactly.

Regarding the average density per bin, the values start with those calculated for the urbanized area. Where values are missing because activity is not present in some density bins, values are substituted from the overall urbanized area averages.

The proportional distribution of activity by density group is used in the Bzone synthesis process as a sampling distribution to determine the density group of each SimBzone in the urbanized area of an Azone. The average density per group is used to determine the average activity density of each SimBzone.

```{r echo=FALSE}
#=========================================================================
#DEVELOP A MODEL FOR PREDICTING DENSITY BY BIN FROM URBANIZED AREA DENSITY
#=========================================================================
#The model adjusts the distribution of activity by density group in response to
#a change in the overall density of the urbanized area. This is done by
#iteratively taking a weighted moving average of the activity proportion in each
#bin with the activity proportion in the bin to the left (if overall density
#increases) or to the right (if overall density decreases).

#Define function to adjust density distribution
#----------------------------------------------
#' Adjust urbanized area density distribution to match average density target
#' 
#' @param DenDist_ A numeric vector of the proportions of urbanized activity by 
#' activity density bin for the urbanized area.
#' @param AveDensity_ A numeric vector of the average activity density by
#' activity density bin for the urbanized area.
#' @param Target A number specifying the average activity density for the
#' urbanized area.
#' @param UzaAveDensity_ A numeric vector of the average activity density by
#' activity density bin for all urbanized areas.
#' @return A data frame having 20 rows and 2 columns: ActProp, the proportion of
#' urbanized activity by activity density bin; and AveDensity, the average
#' density by activity density bin.
adjDenDist <- function(DenDist_, AveDensity_, Target, UzaAveDensity_) {
  #Fill in NA values in DenDist_ and AveDensity_
  DenDist_[is.na(DenDist_)] <- 0
  AveDensity_[is.na(AveDensity_)] <- UzaAveDensity_[is.na(AveDensity_)]
  #Define function to calculate overall average density
  calcAveDensity <- function(AveDensity_, PropActivity_) {
    sum(1 / sum(PropActivity_ / AveDensity_, na.rm = TRUE), na.rm = TRUE)
  }
  #Initial calculation of average density
  AveDensity <- calcAveDensity(AveDensity_, DenDist_)
  #Define a function to make an incremental adjustment in density distribution
  makeAdj <- function(DenDist_, AdjProp){
    if (Target > AveDensity) {
      ShiftDist_ <- c(0, DenDist_[-length(DenDist_)])
    } else {
      ShiftDist_ <- c(DenDist_[-1], 0)
    }
    AdjDenDist_ <- (1 - AdjProp) * DenDist_ + AdjProp * ShiftDist_
    AdjDenDist_ / sum(AdjDenDist_)    
  }
  #Make incremental adjustments until target is approximately achieved
  while (abs(1 - (Target / AveDensity)) > 0.01) {
    TargetDiff <- abs(Target - AveDensity)
    if (TargetDiff > 0.1) {
      DenDist_ <- makeAdj(DenDist_, 0.01)
    } else {
      DenDist_ <- makeAdj(DenDist_, 0.001)
    }
    AveDensity <- calcAveDensity(AveDensity_, DenDist_)
  }
  #Make final adjustments to density bin averages
  AveDensity_ <- AveDensity_ * Target / AveDensity
  #Return data frame of density distribution and average density
  data.frame(
    ActProp = DenDist_,
    AveDensity = AveDensity_
  )
}
```

The following figure shows how the density distribution adjustment works when the density of the urbanized area decreases. In this test, the overall activity density of the Portland (OR) urbanized area is decreased to be equal to that of the Atlanta urbanized area (`r round(ActDen_Ua["Atlanta, GA"], 2)` households and jobs per acre). 

```{r echo=FALSE}
#Test function with with Portland decreasing to density of Atlanta
#-----------------------------------------------------------------
AdjDenDist_df <- adjDenDist(
  D1DGrp_Ua_ls[["Portland, OR"]]$PropActivity, 
  D1DGrp_Ua_ls[["Portland, OR"]]$AveDensity, 
  ActDen_Ua["Atlanta, GA"], 
  D1DGrp_ls$AveDensity)
```

The adjustment method produces a density distribution for the hypothetical Portland that has an an equivalent overall activity density (`r round(calcAveDensity(AdjDenDist_df$AveDensity, AdjDenDist_df$ActProp), 2)`). The distribution of activity by density group is similar to that of Atlanta. It is not the same, however, because it reflects the Portland area starting conditions as well.

```{r echo=FALSE}
#Plot comparison of density distributions
plot(D1DGrp_Ua_ls[["Portland, OR"]]$PropActivity,
     xlab = "Activity Density (D1D) Group",
     ylab = "Proportion of Activity (HHs & Jobs)",
     main = "Test of Adjusting Urbanized Area Average Activity Density (D1D) Downward\nPortland (OR) Activity Density -> Atlanta Activity Density")
addSmoothLine(1:20, D1DGrp_Ua_ls[["Portland, OR"]]$PropActivity)
points(1:20, AdjDenDist_df$ActProp, col="red")
addSmoothLine(1:20, AdjDenDist_df$ActProp, col="red")
points(1:20, D1DGrp_Ua_ls[["Atlanta, GA"]]$PropActivity, col = "green")
addSmoothLine(1:20, D1DGrp_Ua_ls[["Atlanta, GA"]]$PropActivity, col = "green")
legend("topleft", lty = 1, col = c("black", "red", "green"), bty = "n",
       legend = c("Portland Density", "Portland at Atlanta Density", "Atlanta Density"))
#Clean up
rm(AdjDenDist_df, calcAveDensity)
```

The following figure shows how the density distribution adjustment works when the density of the urbanized area increases. In this test, the overall activity density of the Portland (OR) urbanized area is increased to be to be equal to that of the New York (NY) urbanized area (`r round(ActDen_Ua["New York--Newark, NY"], 2)` households and jobs per acre).

```{r echo=FALSE}
#Test function with Portland increasing to density of New York
#-------------------------------------------------------------
calcAveDensity <- function(AveDensity_, PropActivity_) {
  sum(1 / sum(PropActivity_ / AveDensity_, na.rm = TRUE), na.rm = TRUE)
}
AdjDenDist_df <- adjDenDist(
  D1DGrp_Ua_ls[["Portland, OR"]]$PropActivity, 
  D1DGrp_Ua_ls[["Portland, OR"]]$AveDensity, 
  ActDen_Ua["New York--Newark, NY"], 
  D1DGrp_ls$AveDensity)
```

The adjustment method produces a density distribution for the hypothetical Portland that has an an equivalent overall activity density (`r round(calcAveDensity(AdjDenDist_df$AveDensity, AdjDenDist_df$ActProp), 2)`). The distribution of activity by density group differs from that of the New York, especially at the top end of the distribution. This is reasonable because the density distribution of the New York area is a result of the history of that area. Even if the Portland area reached the New York area density at some point in the future, its history would be different and so its density distribution is unlikely to be the same.

```{r echo=FALSE}
#Plot comparison of density distributions
plot(D1DGrp_Ua_ls[["Portland, OR"]]$PropActivity,
     xlab = "Activity Density (D1D) Group",
     ylab = "Proportion of Activity (HHs & Jobs)",
     main = "Test of Adjusting Urbanized Area Average Activity Density (D1D) Upward\nPortland (OR) Activity Density -> New York (NY) Activity Density")
addSmoothLine(1:20, D1DGrp_Ua_ls[["Portland, OR"]]$PropActivity)
points(1:20, AdjDenDist_df$ActProp, col="red")
addSmoothLine(1:20, AdjDenDist_df$ActProp, col="red")
points(1:20, D1DGrp_Ua_ls[["New York--Newark, NY"]]$PropActivity, col = "green")
addSmoothLine(1:20, D1DGrp_Ua_ls[["New York--Newark, NY"]]$PropActivity, col = "green")
legend("topleft", lty = 1, col = c("black", "red", "green"), bty = "n",
       legend = c("Portland Density", "Portland at New York Density", "New York Density"))
rm(AdjDenDist_df)
```

# Modeling Activity Diversity as a Function of Activity Density
Although the correlation between block group activity diversity and activity density is weak, there are some relationships at an aggregate level that can be caputured and used in the model. Census block groups that have a high level of activity density tend to also have an activity mix that is dominated by employment. Census block groups that have a low level of activity density tend to have an activity mix that is dominated by households. A more balanced mix of jobs and households is found more often at mid-range densities.

Because of the weak relationship between density and diversity and reflecting earlier work on [place types](https://github.com/gregorbj/Placetypes_USA), 5 diversity categories are defined as follows based on the ratio of jobs to households:

| Category     | Value Range |
|:-------------|:------------|
|primarily-hh  |0 - 0.25     |
|largely-hh    |0.25 - 0.5   |
|mixed         |0.5 - 2      | 
|largely-job   |2 - 4        |
|primarily-job |4 - infinity |

```{r echo=FALSE}
#==============================================================
#ANALYSE RELATIONSHIP OF DIVERSITY (D2A_JPHH) AND DENSITY (D1D)
#==============================================================
#Although the correlation between block group activity diversity (D2A_JPHH) and
#density (D1D) is weak, there are relationships at an aggregate level that are
#useful to capture. For example, urbanized areas characterized by very high
#density levels tend to have high ratios to jobs to households.

#Identify diversity group levels
#-------------------------------
#5 diversity group levels are defined from a lowest level where households
#dominate to the highest level where jobs dominate. The middle level has the
#most balance where the ratio of jobs to households and the inverse ratio does
#not exceed 2:1.
D2GrpBrk_ <- c(
  min(D_df$D2A_JPHH), 0.25, 0.5, 2, 4, max(D_df$D2A_JPHH)
)
D2 <- c("primarily-hh", "largely-hh", "mixed", "largely-job", "primarily-job")
D2Grp_ <- cut(D_df$D2A_JPHH, D2GrpBrk_, labels = D2, include.lowest = TRUE)
D_df$D2Grp <- D2Grp_
```

The following figure illustrates how the activity is distributed among diversity groups at each activity density level. The 5 diversity groups are shown along the y-axis while the 20 density groups are shown along the x-axis from lowest to highest density. The colors show the proportion of activity in each diversity group for each density group (the values in each column add to 1). It can be seen that except for the very lowest density levels, the employment proportion of activity increases as density increases.

```{r echo=FALSE}
#Calculate proportions of activity by diversity group for each density group
#All urbanized areas
#---------------------------------------------------------------------------
TotAct_D1D2 <- with(D_df, tapply(TOTACT, list(D1DGrp, D2Grp), sum))
TotAct_D1D2[is.na(TotAct_D1D2)] <- 0
D2ActProp_D1D2 <- sweep(TotAct_D1D2, 1, rowSums(TotAct_D1D2), "/")
DispPal_ <- colorRampPalette(c("black", "yellow"))(10)
image2D(D2ActProp_D1D2, 
        x = 1:20, y = 1:5,
        xlab = "Density Group",
        ylab = "Diversity Group",
        zlim = c(0,1),
        col = DispPal_, NAcol = "black",
        axes = FALSE,
        main = "Diversity Group Activity Proportions by Density Group\nAll Urbanized Areas")
axis(1)
axis(2, at = 1:5, labels = D2)
```

Distributions of activity by diversity group for each density group are also tabulated for each named urbanized area in the SLD. These distributions are used as sampling distributions to determine the diversity group of each SimBzone once the density group of the SimBzone has been determined. Where an urbanized area does not have diversity proportions for one or more density groups, the values for the overall tabulation for urbanized areas are used.

The following figure displays the tabulations for the same 9 urbanized areas compared previously. The images illustrate that there is a lot of variation in the diversity-density patterns of urbanized area. It also illustrates some general trends. Lower density urbanized areas tend to have greater segmentation of diversity by density group, and a narrower range of densities supporting mixed development.

```{r echo=FALSE}
#Urbanized area proportions of activity by diversity group at each density group
#-------------------------------------------------------------------------------
#Calculate relationship for each urbanized area
Tmp_Ua_df <- split(D_df, D_df$UZA_NAME)
D2ActProp_Ua_D1D2 <- lapply(Tmp_Ua_df, function(x) {
  TotAct_D1D2 <- tapply(x$TOTACT, list(x$D1DGrp, x$D2Grp), sum)
  D2ActProp_D1D2 <- 
    sweep(TotAct_D1D2, 1, rowSums(TotAct_D1D2, na.rm = TRUE), "/")
  D2ActProp_D1D2[is.nan(D2ActProp_D1D2)] <- 0
  D2ActProp_D1D2
})
ActProp_Ua_D2 <- lapply(Tmp_Ua_df, function(x) {
  TotAct_D2 <- tapply(x$TOTACT, x$D2Grp, sum)
  TotAct_D2[is.na(TotAct_D2)] <- 0
  TotAct_D2 / sum(TotAct_D2)
})
rm(Tmp_Ua_df)
#Calculate relationship for each urbanized area size group
Tmp_Sz_df <- split(D_df, D_df$UZA_SIZE)
D2ActProp_Sz_D1D2 <- lapply(Tmp_Sz_df, function(x) {
  TotAct_D1D2 <- tapply(x$TOTACT, list(x$D1DGrp, x$D2Grp), sum)
  D2ActProp_D1D2 <- 
    sweep(TotAct_D1D2, 1, rowSums(TotAct_D1D2, na.rm = TRUE), "/")
  D2ActProp_D1D2[is.nan(D2ActProp_D1D2)] <- 0
  D2ActProp_D1D2
})
ActProp_Sz_D2 <- lapply(Tmp_Sz_df, function(x) {
  TotAct_D2 <- tapply(x$TOTACT, x$D2Grp, sum)
  TotAct_D2[is.na(TotAct_D2)] <- 0
  TotAct_D2 / sum(TotAct_D2)
})
rm(Tmp_Sz_df)
#Add urbanized area size group tabulations to urbanized area list
for (sz in Sz) {
  D2ActProp_Ua_D1D2[[sz]] <- D2ActProp_Sz_D1D2[[sz]]
  ActProp_Ua_D2[[sz]] <- ActProp_Sz_D2[[sz]]
}
rm(D2ActProp_Sz_D1D2, ActProp_Sz_D2)
#Compare diversity patterns for selected metropolitan areas
DispPal_ <- colorRampPalette(c("black", "yellow"))(10)
InitPar_ls <- par(mfrow = c(3,3), mar = c(4,4,3,3), oma = c(0, 0, 2.2, 0))
for (Ua in UzaToPlot_) {
  ImageDat_D1D2 <- D2ActProp_Ua_D1D2[[Ua]]
  image2D(ImageDat_D1D2, 
          x = 1:20, y = 1:5,
          zlim = c(0,1),
          xlab = "Density Group",
          ylab = "Diversity Group",
          col = DispPal_, NAcol = "black",
          main = Ua, axes = FALSE)
  axis(1)
  axis(2, at = 1:5, 
       labels = c("Prn\nHH", "Lrg\nHH", "Mix", "Lrg\nJOB", "Prn\nJOB"))
}
mtext("Activity Proportions by Diversity Group for Each D1D Group\nFor Selected Urbanized Areas", 
      outer = TRUE, line = -0.5)
par(InitPar_ls)
rm(Ua, InitPar_ls)
```

The following figure compares the diversity proportions by density level for the 6 urbanized area size groups. Except for the highest densities and largest size groups, there are no clear distinctions in these patterns. The highest density values differ because high density levels are not found in smaller urbanized areas. The more dispersed pattern in the very large urbanized area size group reflects the high densities and extensive areas found in the few urbanized areas in this group.

```{r echo=FALSE}
#Compare diversity patterns by urbanized area size group
DispPal_ <- colorRampPalette(c("black", "yellow"))(10)
InitPar_ls <- par(mfrow = c(2,3), mar = c(3,3,3,3), oma = c(0, 0, 2.2, 0))
for (sz in Sz) {
  ImageDat_D1D2 <- D2ActProp_Ua_D1D2[[sz]]
  image2D(ImageDat_D1D2, 
          x = 1:20, y = 1:5,
          zlim = c(0,1),
          xlab = "Density Group",
          ylab = "Diversity Group",
          col = DispPal_, NAcol = "black",
          main = sz, axes = FALSE)
  axis(1)
  axis(2, at = 1:5, 
       labels = c("Prn\nHH", "Lrg\nHH", "Mix", "Lrg\nJOB", "Prn\nJOB"))
}
mtext("Activity Proportions by Diversity Group for Each D1D Group\nBy Urbanized Area Size", 
      outer = TRUE, line = -0.5)
par(InitPar_ls)
rm(InitPar_ls, ImageDat_D1D2, DispPal_)
```

Once a diversity level has been assigned to each SimBzone it is necessary to determine the specific proportion of activity that is jobs vs. households. This is done by sampling from distributions of the job proportions of activity by diversity group. The following figure shows for urbanized areas as a whole the proportions of block group activity at each job proportion level, segmented by diversity level. Tabulations are made for each named urbanized area in the SLD as well as for each urbanized area size group. These are used as sampling distributions to determine the job proportion of activity of each SimBzone based on the diversity level of the SimBzone. Once the SimBone job proportion is determined, SimBzone activity is split into jobs and households. Before this is done, however, the numbers of jobs and households in each Azone portion of the urbanized area area compared to the Azone inputs and adjustments are made so the SimBzone splits to sum up to the Azone inputs.

```{r echo=FALSE}
#Calculate distribution of job proportions by diversity level
#------------------------------------------------------------
#The proportion of block group activity that is jobs is calculated as a more
#useful diversity measure to use to allocate SimBzone activity between jobs and
#households. For each diversity level, distributions of the jobs proportion of
#activity is calculated. These distributions will be sampling distributions.
TotAct_ <- D_df$TOTACT
PropEmp_ <- D_df$EMPTOT / TotAct_
EmpProp_D2_ls <- list()
for (d2 in D2) {
  DoSelect_ <- as.character(D2Grp_) == d2
  PropEmpToPlot_ <- rep(PropEmp_[DoSelect_], TotAct_[DoSelect_])
  Tmp_HS <- hist(PropEmpToPlot_, plot = FALSE)
  EmpProp_D2_ls[[d2]] <- list(
    Values = Tmp_HS$mids,
    Probs = Tmp_HS$counts / sum(Tmp_HS$counts)
  )
  rm(DoSelect_, PropEmpToPlot_, Tmp_HS)
}
rm(d2)
#Plot the distribution of proportion of employment by diversity level
Opar_ls <- par(mfrow = c(2,3), oma = c(0,0,3,0))
for (d2 in D2) {
  DoSelect_ <- as.character(D2Grp_) == d2
  PropEmpToPlot_ <- rep(PropEmp_[DoSelect_], TotAct_[DoSelect_])
  hist(PropEmpToPlot_, freq = FALSE,
       xlab = "Jobs Proportion",
       main = d2)
  rm(DoSelect_, PropEmpToPlot_)
}
mtext(
  text = paste0("Distribution Block Group Activity by Job Proportion of Activity\n",
                "By Jobs-Household Ratio Level"),
  side = 3, line = 0, outer = TRUE)
par(Opar_ls)
rm(PropEmp_, TotAct_, Opar_ls)
```

# Modeling Destination Accessibility as a Function of Activity Density
Destination accessibility groups are defined in the same way that activity density groups are defined. 20 levels of destination accessibility are defined. 

```{r echo=FALSE}
#==================================================================================
#ANALYZE RELATIONSHIP OF DESTINATION ACCESSIBILITY (D5) WITH ACTIVITY DENSITY (D1D)
#==================================================================================

#Create destination accessibility (D5) levels
#--------------------------------------------
#Determine breaks by dividing log of distribution into 20 equal intervals
D5GrpBrk_ <- local({
  LogD5_ <- log(D_df$D5)
  Interval <- diff(range(LogD5_)) / 20
  LogBreaks_ <- min(LogD5_) + 0:20 * Interval
  exp(LogBreaks_)
})
#Make sure the minimum and maximum values bound the breaks
D5GrpBrk_[1] <- min(D_df$D5)
D5GrpBrk_[length(D5GrpBrk_)] <- max(D_df$D5)
#Identify the destination accessibility group for each block group
D5Grp_ <- cut(D_df$D5, breaks = D5GrpBrk_, include.lowest = TRUE)
D_df$D5Grp <- D5Grp_
#Calculate the average destination accessibility for each quantile
D5GrpAve_ <- tapply(D_df$D5, D5Grp_, mean)
#Calculate total activity in each qualtile
D5GrpTotAct_ <- tapply(D_df$TOTACT, D5Grp_, sum)
```

The following figure shows how the distribution of urbanized area activity varies by destination accessibility group.

```{r echo=FALSE}
#Plot the proportion of total activity by group
D5GrpPropAct_ <- D5GrpTotAct_ / sum(D5GrpTotAct_)
plot(1:20, D5GrpPropAct_,
     xlab = "Destination Accessibility (D5) Group",
     ylab = "Proportion of Activity (HHs & Jobs)",
     main = "Proportions of Activity by Destination Accesibility Group\nBlock Groups in All Urbanized Areas")
addSmoothLine(1:20, D5GrpPropAct_, lty = 2)
```

The following figure shows how average destination accessibility varies by density group.

```{r echo=FALSE}
#Plot the group D5 averages
plot(1:20, D5GrpAve_,
     xlab = "Destination Accessibility (D5) Group",
     ylab = "Average Destination Accessibility",
     main = "Average Destination Accessibility by Destination Accessibility Group\nBlocks Groups in All Urbanized Areas")
addSmoothLine(1:20, D5GrpAve_, lty = 2)
#Clean up
rm(D5GrpBrk_, D5Grp_, D5GrpAve_, D5GrpTotAct_, D5GrpPropAct_)
```

Tabulations of activity proportions by destination accessibility group are made for each density group. These tabulations are made for urbanized areas as a whole, for each urbanized area, and for each urbanized area size group. As with the diversity-density tabulations, these tabulations are used as sampling distributions to determine the destination accessibility level for each SimBzone based on the density level.

```{r echo=FALSE}
#Calculate activity jointly by density (D1D) and accessibility (D5) groupings
#----------------------------------------------------------------------------
#Calculate total activity by density group and accessibility group and the
#activity proportions by accessibility group for each density group
#Calculate for all urbanized areas
TotAct_D1D5 <- tapply(D_df$TOTACT, list(D_df$D1DGrp, D_df$D5Grp), sum)
TotAct_D1D5[is.na(TotAct_D1D5)] <- 0
D5ActProp_D1D5 <- sweep(TotAct_D1D5, 1, rowSums(TotAct_D1D5), "/")
#Calculate by urbanized area
D_Ua_df <- split(D_df, D_df$UZA_NAME)
TotAct_Ua_D1D5 <- lapply(D_Ua_df, function(x) {
  TotAct_D1D5 <- tapply(x$TOTACT, list(x$D1DGrp, x$D5Grp), sum)
  TotAct_D1D5
})
D5ActProp_Ua_D1D5 <- lapply(TotAct_Ua_D1D5, function(x) {
  D5ActProp_D1D5 <- sweep(x, 1, rowSums(x, na.rm = TRUE), "/")
  D5ActProp_D1D5
})
ActProp_Ua_D5 <- lapply(D_Ua_df, function(x) {
  TotAct_D5 <- tapply(x$TOTACT, x$D5Grp, sum)
  TotAct_D5[is.na(TotAct_D5)] <- 0
  TotAct_D5 / sum(TotAct_D5)
})
rm(D_Ua_df, TotAct_Ua_D1D5)
#Calculate by urbanized area size group
D_Sz_df <- split(D_df, D_df$UZA_SIZE)
TotAct_Sz_D1D5 <- lapply(D_Sz_df, function(x) {
  TotAct_D1D5 <- tapply(x$TOTACT, list(x$D1DGrp, x$D5Grp), sum)
  TotAct_D1D5
})
D5ActProp_Sz_D1D5 <- lapply(TotAct_Sz_D1D5, function(x) {
  D5ActProp_D1D5 <- sweep(x, 1, rowSums(x, na.rm = TRUE), "/")
  D5ActProp_D1D5
})
ActProp_Sz_D5 <- lapply(D_Sz_df, function(x) {
  TotAct_D5 <- tapply(x$TOTACT, x$D5Grp, sum)
  TotAct_D5[is.na(TotAct_D5)] <- 0
  TotAct_D5 / sum(TotAct_D5)
})
rm(D_Sz_df, TotAct_Sz_D1D5)
#Add size group tabulations to urbanized area list
for (sz in Sz) {
  D5ActProp_Ua_D1D5[[sz]] <- D5ActProp_Sz_D1D5[[sz]]
  ActProp_Ua_D5[[sz]] <- ActProp_Sz_D5[[sz]]
}
rm(D5ActProp_Sz_D1D5, sz)

#Define function to make an image of proportions of total activity by D1D and D5
#-------------------------------------------------------------------------------
imagePropAct <- function(D5PropAct_D1D5, ...) {
  ImgDat_D1D5 <- D5PropAct_D1D5
  ImgDat_D1D5[is.na(ImgDat_D1D5)] <- 0
  DispPal_ <- colorRampPalette(c("black", "yellow"))(20)
  image2D(ImgDat_D1D5, 
          x = 1:20, y = 1:20,
          zlim = c(0,1),
          col = DispPal_, NAcol = "black",
          xlab = "",
          ylab = "",
          ...)
  title(ylab = "D5 Group", line = 1)
  title(xlab = "D1D Group", line = 1)
}
```

The following figure shows the destination accessibility-density relationship for all urbanized areas. The relatively high correlation between block group values can be seen in the figure. Except for the lowest density, all the non-zero values are arranged near the diagonal.

```{r echo=FALSE}
#Plot relationships of D5 group proportions with D1D group
#---------------------------------------------------------
#Plot D5 group proportions for all urbanized areas
imagePropAct(D5ActProp_D1D5,
             main = "Activity Proportions by D5 Group for Each D1D Group\nAll Urbanized Areas")
```

The following figure shows the destination accessibility-density relationship for the same 9 urbanized areas profiled previously. Again, the strength of the relationship between destination accessibility and density can be seen.

```{r echo=FALSE}
#Plot D5 group proportions for 9 urbanized areas
InitPar_ls <- par(mfrow = c(3,3), mar = c(3,3,3,3), oma = c(0, 0, 2.2, 0))
for (Ua in UzaToPlot_) {
  imagePropAct(D5ActProp_Ua_D1D5[[Ua]], main = Ua)
}
mtext("Activity Proportions by D5 Group for Each D1D Group\nFor Selected Urbanized Areas", 
      outer = TRUE, line = -0.5)
par(InitPar_ls)
rm(Ua, InitPar_ls)
```

The following figure shows the relationship between destination accessibility and activity density by urbanized area size group.

```{r echo=FALSE}
#Plot D5 group proportions for 6 urbanized area size groups
InitPar_ls <- par(mfrow = c(3,2), mar = c(3,3,3,3), oma = c(0, 0, 2.2, 0))
for (sz in Sz) {
  imagePropAct(D5ActProp_Ua_D1D5[[sz]], main = sz)
}
mtext("Activity Proportions by D5 Group for Each D1D Group\nBy Urbanized Area Population Size Group", 
      outer = TRUE, line = -0.5)
par(InitPar_ls)
rm(InitPar_ls)
```

The average urbanized area destination accessibility by level is calculated for all urbanized areas, for each urbanized area, and for each urbanized area size category. Once the destination accessibility level for a SimBzone has been determined, the destination accessibility value for the SimBzone is taken from that average value for the level for the urbanized area. Missing urbanized area values are filled in from the overall urbanized area averages.


```{r echo=FALSE}
#Calculate average destination accessibility by destination accessibility group
#------------------------------------------------------------------------------
#Calculate for all urbanized areas
D5Ave_D5 <- unlist(lapply(split(D_df, D_df$D5Grp), function(x) {
  sum(x$TOTACT * x$D5) / sum(x$TOTACT)
}))
#Calculate by urbanized area
Tmp_Ua_df <- split(D_df, D_df$UZA_NAME)
D5Ave_Ua_D5 <- lapply(Tmp_Ua_df, function(x) {
  unlist(lapply(split(x, x$D5Grp), function(y) {
    sum(y$TOTACT * y$D5) / sum(y$TOTACT)
  }))
})
rm(Tmp_Ua_df)
#Calculate by urbanized area size group
Tmp_Sz_df <- split(D_df, D_df$UZA_SIZE)
D5Ave_Sz_D5 <- lapply(Tmp_Sz_df, function(x) {
  unlist(lapply(split(x, x$D5Grp), function(y) {
    sum(y$TOTACT * y$D5) / sum(y$TOTACT)
  }))
})
rm(Tmp_Sz_df)
#Add size group tabulations to urbanized area list
for (sz in Sz) {
  D5Ave_Ua_D5[[sz]] <- D5Ave_Sz_D5[[sz]]
}
rm(D5Ave_Sz_D5)
```

# Implementing Bzone Synthesis
The Bzone synthesis process is implemented in a function which does the following:  

1) Azone level urbanized area allocations of households and jobs, and the land area of the urbanized area determine the basic constraints that the zone synthesis must meet.

2) For each Azone portion of the urbanized area SimBzones are created. The number of SimBzones is the whole number result (by rounding) of dividing the total activity allocated to the urbanized area in the Azone by 750. The remainder (positive or negative) is randomly allocated to the SimBzones.

3) Each SimBzone is assigned an activity density level. First a proportional allocation of activity to activity density levels is calculated such that the distribution averages to the average density for the urbanized area in the Azone. This is accomplished by starting with the urbanized area profile of the proportional distribution by activity density level and then adjusting those proportions in small increments until the average density for the urbanized area is achieved. The mean density profile for the urbanized area is used in this calculation. Missing values in the mean density profile are filled in with values from the profile for urbanized areas as a whole. The proportional allocation of activity by density level is used as a sampling distribution to assign each SimBzone a density level. This process is carried out separately for each Azone portion of the urbanized area. A final density adjustment is made so that the average activity density in each Azone urbanized area matches input assumptions. 

4) Each SimBzone is assigned a diversity level by using the urbanized area profile of proportional allocations of activity by diversity level for each activity density level for sampling distributions. Missing values are filled in from the overall urbanized area profile. Once the diversity level has been chosen a value for the employment proportion of activity is picked for each SimBzone from the employment proportions distributions. The employment proportions are used to make an initial calculation of employment in each SimBzone. That employment is adjusted as necessary to match the urbanized area employment total in each Azone. The number of SimBzone households is then calculated.

5) SimBzones are assigned destination accessibility levels in a similar manner. The urbanized area profile of proportional allocations of activity by destination accessibility level are used as sampling distributions to determine destination accessibility levels. Missing values are filled in from the overall urbanized area profile. The specific destination accessibility values are the mean values computed for the levels for the urbanized area. If destination accessibility proportions are missing for one or more density levels, they are filled in from the profile for urbanized areas as a whole.

```{r echo=FALSE}
#Make a list containing all of the estimated distributions
#---------------------------------------------------------
Ds_ls <- list(
  D1DGrp_ls =  D1DGrp_ls,
  D1DGrp_Ua_ls = D1DGrp_Ua_ls,
  ActProp_Ua_D2 = ActProp_Ua_D2,
  ActProp_Ua_D5 = ActProp_Ua_D5,
  D2ActProp_D1D2 = D2ActProp_D1D2,
  D2ActProp_Ua_D1D2 = D2ActProp_Ua_D1D2,
  EmpProp_D2_ls = EmpProp_D2_ls,
  D5ActProp_D1D5 = D5ActProp_D1D5,
  D5ActProp_Ua_D1D5 = D5ActProp_Ua_D1D5,
  D5Ave_D5 = D5Ave_D5,
  D5Ave_Ua_D5 = D5Ave_Ua_D5
)

#Define function to create Bzones
#--------------------------------
createUbzBzones <- 
  function(TotHHs_Az, TotJobs_Az, ActDen_Az, UzaName, ActPerBzone = 750) {
    set.seed(1)
    Az <- names(TotHHs_Az)
    #----------------------------------------
    #Create zones to accommodate all activity
    #----------------------------------------
    TotAct_Az <- TotHHs_Az + TotJobs_Az
    SimBzone_Az_df <- lapply(TotAct_Az, function(x) {
      NumZones <- round(x / ActPerBzone)
      RemAct <- x - NumZones * ActPerBzone
      BzName_Bz <- paste0("B", 1:NumZones)
      BzAct_Bz <- rep(ActPerBzone, NumZones)
      if (RemAct != 0) {
        RemAllocation_tb <- table(sample(1:NumZones, abs(RemAct), replace = TRUE))
        Idx_ <- as.numeric(names(RemAllocation_tb))
        Vals_ <- as.vector(RemAllocation_tb)
        BzAct_Bz[Idx_] <- BzAct_Bz[Idx_] + Vals_ * sign(RemAct)
      }
      data.frame(
        Bzone = BzName_Bz,
        Activity = BzAct_Bz
      )
    })
    #Add Azone name onto front of Bzone name
    for (az in Az) {
      SimBzone_Az_df[[az]]$Bzone <- paste0(az, SimBzone_Az_df[[az]]$Bzone)
    }
    #--------------------------------
    #Assign density levels and values
    #--------------------------------
    #Calculate density distributions by Azone
    ActDen_Az_df <- lapply(ActDen_Az, function(x) {
      ActDen_df <- adjDenDist(
        UzaAveDensity_ = Ds_ls$D1DGrp_Ua_ls[[UzaName]]$AveDensity,
        DenDist_ = Ds_ls$D1DGrp_Ua_ls[[UzaName]]$PropActivity,
        Target = x,
        AveDensity_ = Ds_ls$D1DGrp_ls$AveDensity
      )
    })
    #Assign density level and average density to zones
    for (az in Az) {
      D1Grp_Bz <- sample(1:20, nrow(SimBzone_Az_df[[az]]), replace = TRUE,
                         ActDen_Az_df[[az]]$ActProp)
      ActDen_Bz <- ActDen_Az_df[[az]]$AveDensity[D1Grp_Bz]
      #Adjust density to meet target
      Activity_Bz <- SimBzone_Az_df[[az]]$Activity
      AveDensity <- sum(Activity_Bz) / sum(Activity_Bz * 1 / ActDen_Bz)
      ActDen_Bz <- ActDen_Bz * ActDen_Az[az] / AveDensity
      SimBzone_Az_df[[az]]$D1Grp <- D1Grp_Bz
      SimBzone_Az_df[[az]]$D1D <- ActDen_Bz
      rm(D1Grp_Bz, ActDen_Bz, Activity_Bz, AveDensity)
    }
    rm(ActDen_Az_df)
    #----------------------------------------------------------------------
    #Functions to assist diversity and destination accessibility assignment
    #----------------------------------------------------------------------
    #Define function to fill in missing activity proportions
    fillMissingUaActProp <- function(UaActProp_mx, ActProp_mx) {
      NaRows_ <- apply(UaActProp_mx, 1, function(x) all(is.na(x)))
      UaActProp_mx[NaRows_,] <- ActProp_mx[NaRows_,]
      UaActProp_mx[is.na(UaActProp_mx)] <- 0
      UaActProp_mx
    }
    #Define function to identify urbanized area size category
    idSizeCategory <- function(TotActivity) {
      SzBrk_ <- c(0, 5e4, 1e5, 5e5, 1e6, 5e6, 1e9)
      Sz <- c("small", "medium-small", "medium", "medium-large", "large", "very-large")
      as.character(cut(TotActivity, SzBrk_, labels = Sz, include.lowest = TRUE))
    }
    #--------------------------------------------------------
    #Assign diversity level and calculate households and jobs
    #--------------------------------------------------------
    #Create D2 activity proportions sampling matrix
    D2ActProp_D1D2 <- 
      fillMissingUaActProp(
        Ds_ls$D2ActProp_Ua_D1D2[[UzaName]], Ds_ls$D2ActProp_D1D2)
    #Assign diversity values to Bzones
    for (az in Az) {
      SimBzone_df <- SimBzone_Az_df[[az]]
      #Assign diversity levels
      D2Grp_Bz <- sapply(SimBzone_df$D1Grp, function(x) {
        sample(colnames(D2ActProp_D1D2), 1, prob = D2ActProp_D1D2[x,])
      })
      #Calculate numbers of jobs by Bzone
      EmpProp_Bz <- sapply(D2Grp_Bz, function(x) {
        Sample_ls <- Ds_ls$EmpProp_D2_ls[[x]]
        sample(Sample_ls$Values, 1, prob = Sample_ls$Probs)
      })
      Jobs_Bz <- unname(round(SimBzone_df$Activity * EmpProp_Bz))
      #Adjust jobs to match inputs
      TargetJobs <- TotJobs_Az[az]
      JobDiff <- TargetJobs - sum(Jobs_Bz)
      JobsProp_Bz <- Jobs_Bz / sum(Jobs_Bz)
      JobsAdj_Bx <- table(
        sample(1:nrow(SimBzone_df), abs(JobDiff), replace = TRUE, prob = JobsProp_Bz)
      )
      AdjJobs_Bz <- Jobs_Bz
      AdjIdx_ <- as.numeric(names(JobsAdj_Bx))
      AdjJobs_Bz[AdjIdx_] <- Jobs_Bz[AdjIdx_] + sign(JobDiff) * JobsAdj_Bx
      if(any(AdjJobs_Bz > SimBzone_df$Activity)) {
        AdjJobs_Bz[AdjJobs_Bz > SimBzone_df$Activity] <- 
          SimBzone_df$Activity[AdjJobs_Bz > SimBzone_df$Activity]
      }
      #Calculate numbers of households by Bzone
      HHs_Bz <- SimBzone_df$Activity - AdjJobs_Bz
      #Calculate Jobs - HHs ratio
      D2A_JPHH_Bz <- AdjJobs_Bz / HHs_Bz
      #Assign values to SimBzones
      SimBzone_Az_df[[az]]$D2Grp <- D2Grp_Bz
      SimBzone_Az_df[[az]]$Jobs <- AdjJobs_Bz
      SimBzone_Az_df[[az]]$HHs <- HHs_Bz
      SimBzone_Az_df[[az]]$`D2A_JPHH` <- D2A_JPHH_Bz
    }
    #--------------------------------------
    #Assign Destination Accessibility Level
    #--------------------------------------
    #Calculate total urbanized activity and identify size group
    # TotAct <- sum(TotHHs_Az) + sum(TotJobs_Az) 
    # UaSizeGrp <- idSizeCategory(TotAct)
    #Create D5 activity proportions sampling matrix
    # D5ActProp_D1D5 <- 
    #   fillMissingUaActProp(
    #     Ds_ls$D5ActProp_Ua_D1D5[[UzaName]], Ds_ls$D5ActProp_Ua_D1D5[[UaSizeGrp]])
    D5ActProp_D1D5 <- 
      fillMissingUaActProp(
        Ds_ls$D5ActProp_Ua_D1D5[[UzaName]], Ds_ls$D5ActProp_D1D5)
    #Create vector of D5 averages by activity density level
    D5Ave_D5 <- Ds_ls$D5Ave_Ua_D5[[UzaName]]
    #D5SzGrpAve_D5 <- Ds_ls$D5Ave_Ua_D5[[UaSizeGrp]]
    #D5Ave_D5[is.nan(D5Ave_D5)] <- D5SzGrpAve_D5[is.nan(D5Ave_D5)]
    D5Ave_D5[is.nan(D5Ave_D5)] <- Ds_ls$D5Ave_D5[is.nan(D5Ave_D5)]
    #Fill in missing values as moving average
    D5Ave_D5[is.nan(D5Ave_D5)] <- 0
    D5MovAve_D5 <- 
      (c(D5Ave_D5[-1], max(D5Ave_D5)) + c(min(D5Ave_D5), D5Ave_D5[1:19])) / 2
    D5Ave_D5[D5Ave_D5 == 0] <- D5MovAve_D5[D5Ave_D5 == 0]
    #Iterate through Azones to assign destination accessibility
    for (az in Az) {
      SimBzone_df <- SimBzone_Az_df[[az]]
      #Assign D5Grp
      D5Grp_Bz <- sapply(SimBzone_df$D1Grp, function(x) {
        sample(1:ncol(D5ActProp_D1D5), 1, prob = D5ActProp_D1D5[x,])
      })
      SimBzone_Az_df[[az]]$D5Grp <- D5Grp_Bz
      #Assign D5 value
      D5_Bz <- D5Ave_D5[D5Grp_Bz]
      SimBzone_Az_df[[az]]$D5 <- D5_Bz
    }
    #------------------
    #Return the results
    #------------------
    SimBzone_Az_df
  }
```

The zone synthesis process is tested by synthesizing Bzones for the 9 example metropolitan areas and comparing the activity proportions for the synthesized zone with the activity proportions for the metropolitan area block groups. In general, the synthesis process does a good job of replicating the observed values for these metropolitan areas. The process tends to overestimate the proportion of activity in higher density levels. This in turn results in an overestimation of the proportion of activity in 'primarily-job' oriented Bzones and in higher destination accessibility groups. This may be a result of the combination of applying the density adjustment function at the Azone level (i.e. county level for this test). The largest difference can be seen for the New York urbanized area.

```{r echo=FALSE}
#Define function to create test Azone inputs
#-------------------------------------------
#This function takes the data for an urbanized area and splits it at the county
#level considering counties to be Azones. It then produces each of the required
#inputs at the Azone level.
createAzoneTestData <- function(UzaName) {
  Uza_df <- D_df[D_df$UZA_NAME == UzaName,]
  Azone_Bg <- 
    paste0("A", sapply(Uza_df$GEOID10, function(x) substr(x, 1, 5)))
  TotJobs_Az <- tapply(Uza_df$EMPTOT, Azone_Bg, sum)
  TotHHs_Az <- tapply(Uza_df$HH, Azone_Bg, sum)
  TotAct_Az <- tapply(Uza_df$TOTACT, Azone_Bg, sum)
  TotAcLand_Az <- tapply(Uza_df$AC_LAND, Azone_Bg, sum)
  ActDen_Az <- TotAct_Az / TotAcLand_Az
  list(
    TotJobs_Az = TotJobs_Az,
    TotHHs_Az = TotHHs_Az,
    ActDen_Az = ActDen_Az
  )
}

#Define function to tabulate activity by group(s)
tabSimBzoneAct <- function(SimBzones_Az_df, VarNames, VarDimnames) {
  SimB_df <- do.call(rbind, SimBzones_Az_df)
  if (length(VarNames) == 1) {
    Act_ <- numeric(length(VarDimnames))
    names(Act_) <- VarDimnames
    TabAct_ <- tapply(SimB_df$Activity, SimB_df[[VarNames]], sum)
    Act_[names(TabAct_)] <- TabAct_
    Act_[is.na(Act_)] <- 0
    return(Act_)
  }
  if (length(VarNames) == 2) {
    Act_mx <- matrix(0, nrow = length(VarDimnames[[1]]), ncol = length(VarDimnames[[2]]))
    dimnames(Act_mx) <- VarDimnames
    TabAct_mx <- with(SimB_df, tapply(Activity, as.list(SimB_df[VarNames]), sum))
    Idx_mx <- as.matrix(expand.grid(rownames(TabAct_mx), colnames(TabAct_mx)))
    Act_mx[Idx_mx] <- as.vector(TabAct_mx)
    Act_mx[is.na(Act_mx)] <- 0
    return(Act_mx)
  }
  stop("Can't tabulate by more than 2 VarNames")
}

#Define function to summarize SimBzone activity
summarizeSimBzones <- function(SimBzones_Az_df) {
  D1Names <- as.character(1:20)
  D5Names <- as.character(1:20)
  D2Names <- 
    c("primarily-hh", "largely-hh", "mixed", "largely-job", "primarily-job")
  Act_D1 <- tabSimBzoneAct(SimBzones_Az_df, "D1Grp", D1Names)
  PropAct_D1 <- Act_D1 / sum(Act_D1)
  Act_D2 <- tabSimBzoneAct(SimBzones_Az_df, "D2Grp", D2Names)
  PropAct_D2 <- Act_D2 / sum(Act_D2)
  Act_D5 <- tabSimBzoneAct(SimBzones_Az_df, "D5Grp", D5Names)
  PropAct_D5 <- Act_D5 / sum(Act_D5)
  Act_D1D2 <- tabSimBzoneAct(SimBzones_Az_df, c("D1Grp", "D2Grp"), list(D1Names, D2Names))
  D2PropAct_D1D2 <- sweep(Act_D1D2, 1, rowSums(Act_D1D2), "/")
  D2PropAct_D1D2[is.na(D2PropAct_D1D2)] <- 0
  Act_D1D5 <- tabSimBzoneAct(SimBzones_Az_df, c("D1Grp", "D5Grp"), list(D1Names, D5Names))
  D5PropAct_D1D5 <- sweep(Act_D1D5, 1, rowSums(Act_D1D5), "/")
  D5PropAct_D1D5[is.na(D5PropAct_D1D5)] <- 0
  list(
    PropAct_D1 = PropAct_D1,
    PropAct_D2 = PropAct_D2,
    PropAct_D5 = PropAct_D5,
    PropAct_D1D2 = D2PropAct_D1D2,
    PropAct_D1D5 = D5PropAct_D1D5
  )
}

#Define function to collate observed urbanized area values
collateUbzSummaries <- function(Ds_ls, UaName) {
  PropAct_D1 <- Ds_ls$D1DGrp_Ua_ls[[UaName]]$PropActivity
  PropAct_D1[is.na(PropAct_D1)] <- 0
  PropAct_D2 <- Ds_ls$ActProp_Ua_D2[[UaName]]
  PropAct_D2[is.na(PropAct_D2)] <- 0
  PropAct_D5 <- Ds_ls$ActProp_Ua_D5[[UaName]]
  PropAct_D5[is.na(PropAct_D5)] <- 0
  PropAct_D1D2 <- D2ActProp_Ua_D1D2[[UaName]]
  PropAct_D1D2[is.na(PropAct_D1D2)] <- 0
  PropAct_D1D5 <- D5ActProp_Ua_D1D5[[UaName]]
  PropAct_D1D5[is.na(PropAct_D1D5)] <- 0
  list(
    PropAct_D1 = PropAct_D1,
    PropAct_D2 = PropAct_D2,
    PropAct_D5 = PropAct_D5,
    PropAct_D1D2 = PropAct_D1D2,
    PropAct_D1D5 = PropAct_D1D5
  )
}

#Comparison vector plot
vectorCompare <- function(Est_ls, Obs_ls, VectorName, ...) {
  Obs_ <- Obs_ls[[VectorName]]
  Est_ <- Est_ls[[VectorName]]
  Ylim_ <- range(c(Obs_, Est_))
  Xlab_ <- names(Obs_)
  Xvals_ <- 1:length(Xlab_)
  plot(Xvals_, Obs_, axes = FALSE, ylim = Ylim_, type = "p", 
       ylab = "Activity Proportion",
       ...)
  box()
  axis(2)
  axis(1, at = Xvals_, labels = Xlab_)
  lines(Xvals_, Obs_)
  points(Xvals_, Est_, col = "red")
  lines(Xvals_, Est_, col = "red")
}

#Function to compare observed and estimated density, diversity, and destination accessibility proportions
compareObsEst1 <- function(Obs_ls, Est_ls, UaName) {
  Opar_ls <- par(mfrow = c(2,2), oma = c(0,0,3,0))
  vectorCompare(Est_ls, Obs_ls, "PropAct_D1", 
                xlab = "Density (D1D) Category",
                main = "Density")
  legend("topleft", legend = c("Observed", "Simulated"), bty = "n", lty = 1, col = c("black", "red"))
  vectorCompare(Est_ls, Obs_ls, "PropAct_D2", 
                xlab = "Diversity (D2A_JPHH) Category",
                main = "Diversity")
  vectorCompare(Est_ls, Obs_ls, "PropAct_D5", 
                xlab = "Destination Accessibility (D5) Category",
                main = "Destination Accessibility")
  mtext(text = paste0(UaName, "\nComparison of Density, Diversity, and Destination Accessibility Activity Proportions"), 
        side = 3, outer = TRUE)
  par(Opar_ls)
}

#Function to compare joint distributions
compareObsEst2 <- function(Obs_ls, Est_ls, UaName) {
  Opar_ls <- par(mfrow = c(2,2), oma = c(0,0,3,0))
  Rng_ <- 
    range(c(as.vector(Obs_ls$PropAct_D1D2), as.vector(Est_ls$PropAct_D1D2)))
  DispPal_ <- colorRampPalette(c("black", "yellow"))(20)
  image2D(Obs_ls$PropAct_D1D2, 
          x = 1:20, y = 1:5,
          xlab = "D1D Group", ylab = "D2 Group",
          zlim = Rng_,
          col = DispPal_, NAcol = "black",
          main = paste("Observed Diversity Proportions\nBy Density group"),
          cex.main = 1)
  image2D(Est_ls$PropAct_D1D2, 
          x = 1:20, y = 1:5,
          xlab = "D1D Group", ylab = "D2 Group",
          zlim = Rng_,
          col = DispPal_, NAcol = "black",
          main = paste("Synthesized Diversity Proportions\nBy Density group"),
          cex.main = 1)
  Rng_ <- 
    range(c(as.vector(Obs_ls$PropAct_D1D5), as.vector(Est_ls$PropAct_D1D5)))
  DispPal_ <- colorRampPalette(c("black", "yellow"))(20)
  image2D(Obs_ls$PropAct_D1D5, 
          x = 1:20, y = 1:20,
          xlab = "D1D Group", ylab = "D5 Group",
          zlim = Rng_,
          col = DispPal_, NAcol = "black",
          main = paste("Observed Destination Accessibility Proportions\nBy Density group"),
          cex.main = 1)
  image2D(Est_ls$PropAct_D1D5, 
          x = 1:20, y = 1:20,
          xlab = "D1D Group", ylab = "D5 Group",
          zlim = Rng_,
          col = DispPal_, NAcol = "black",
          main = paste("Synthesized Destination Accessibility Proportions\nBy Density group"),
          cex.main = 1)
  mtext(text = paste0(UaName, "\nComparison of Diversity and Destination Accessibility Proportions by Density Group"), 
        side = 3, outer = TRUE)
  par(Opar_ls)
}

#Function to simulate for urbanized area and compare with observed values
simulateAndCompare <- function(UzaName) {
  UzaTestData_ls <- createAzoneTestData(UzaName)
  SimBzones_Az_df <- 
    createUbzBzones(
      TotHHs_Az = UzaTestData_ls$TotHHs_Az, 
      TotJobs_Az = UzaTestData_ls$TotJobs_Az, 
      ActDen_Az = UzaTestData_ls$ActDen_Az, 
      UzaName = UzaName, 
      ActPerBzone = 750)
  
  Est_ls <- summarizeSimBzones(SimBzones_Az_df)
  Obs_ls <- collateUbzSummaries(Ds_ls, UzaName)
  compareObsEst1(Obs_ls, Est_ls, UzaName)
  compareObsEst2(Obs_ls, Est_ls, UzaName)
}
```

The following 2 figures compare the simulated and observed values for the Atlanta, GA urbanized area. The first figure compares the overall density, diversity, and destination accessibility distributions. The second figure compares the joint diversity and density distribution and the joint destination accessibility and density distribution.

```{r echo=FALSE}
#Simulate and compare several urbanized areas
simulateAndCompare("Atlanta, GA")
```

The following 2 figures compare the simulated and observed values for the Jacksonville, FL urbanized area. The first figure compares the overall density, diversity, and destination accessibility distributions. The second figure compares the joint diversity and density distribution and the joint destination accessibility and density distribution.

```{r echo=FALSE}
simulateAndCompare("Jacksonville, FL")
```

The following 2 figures compare the simulated and observed values for the Cincinnati, OH urbanized area. The first figure compares the overall density, diversity, and destination accessibility distributions. The second figure compares the joint diversity and density distribution and the joint destination accessibility and density distribution.

```{r echo=FALSE}
simulateAndCompare("Cincinnati, OH")
```

The following 2 figures compare the simulated and observed values for the Dallas--Fort Worth--Arlington, TX urbanized area. The first figure compares the overall density, diversity, and destination accessibility distributions. The second figure compares the joint diversity and density distribution and the joint destination accessibility and density distribution.

```{r echo=FALSE}
simulateAndCompare("Dallas--Fort Worth--Arlington, TX")
```

The following 2 figures compare the simulated and observed values for the Baltimore, MD urbanized area. The first figure compares the overall density, diversity, and destination accessibility distributions. The second figure compares the joint diversity and density distribution and the joint destination accessibility and density distribution.

```{r echo=FALSE}
simulateAndCompare("Baltimore, MD")
```

The following 2 figures compare the simulated and observed values for the Denver--Aurora, CO urbanized area. The first figure compares the overall density, diversity, and destination accessibility distributions. The second figure compares the joint diversity and density distribution and the joint destination accessibility and density distribution.

```{r echo=FALSE}
simulateAndCompare("Denver--Aurora, CO")
```

The following 2 figures compare the simulated and observed values for the Portland, OR urbanized area. The first figure compares the overall density, diversity, and destination accessibility distributions. The second figure compares the joint diversity and density distribution and the joint destination accessibility and density distribution.

```{r echo=FALSE}
simulateAndCompare("Portland, OR")
```

The following 2 figures compare the simulated and observed values for the San Francisco--Oakland, CA urbanized area. The first figure compares the overall density, diversity, and destination accessibility distributions. The second figure compares the joint diversity and density distribution and the joint destination accessibility and density distribution.

```{r echo=FALSE}
simulateAndCompare("San Francisco--Oakland, CA")
```

The following 2 figures compare the simulated and observed values for the New York--Newark, NY urbanized area. The first figure compares the overall density, diversity, and destination accessibility distributions. The second figure compares the joint diversity and density distribution and the joint destination accessibility and density distribution.

```{r echo=FALSE}
simulateAndCompare("New York--Newark, NY")
```